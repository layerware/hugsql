---
layout: default
page: docs
---

<div class="container-fluid">

  <div class="row">

    <div class="col-md-8">

      <h2 id="introduction"><img src="/img/hugsql_alpha_128.png"> </h2>

      <p class="lead"><em>HugSQL is a Clojure library for embracing SQL.</em></p>

      <ul>
        <li>SQL is the <em>right tool for the job</em> when working with a relational database!</li>
        <li>HugSQL uses <a href="#detail">simple conventions</a> in
          your SQL files to define (at compile time) database
          functions in your Clojure namespace, creating a clean
          separation of Clojure and SQL code.</li>
        <li>HugSQL supports runtime replacement
          of <a href="#param-value">SQL Value Parameters</a>
          (e.g., <code>where id =
          :id</code>), <a href="#param-identifier">SQL Identifiers</a>
          (i.e. table/column names), and <a href="#param-sql">SQL
          Keywords</a>.  You can
          also <a href="#param-custom">implement your own parameter
          types</a>.</li>
        <li>HugSQL features <a href="#using-expressions">Clojure
          Expressions</a> and <a href="#using-snippets">Snippets</a>
          providing the full expressiveness of Clojure and the
          composability of partial SQL statements when constructing
          complex SQL queries.</li>
        <li>HugSQL has <a href="#adapter">protocol-based adapters</a>
          supporting multiple database libraries and ships with
          adapters for
          <a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a> (default)
          and <a href="http://funcool.github.io/clojure.jdbc/latest/">clojure.jdbc</a></li>
      </ul>


      <h3 class="page-header" id="install">Installation</h3>

      <p><a href="https://github.com/technomancy/leiningen">Leiningen</a>
        dependency information:</p>

{% highlight clj %}
[com.layerware/hugsql "0.4.9"]
{% endhighlight %}

      <p>You will also need to specify your JDBC driver dependency
        from one of the following:</p>

      <ul>
        <li><a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.apache.derby%22%20AND%20a%3A%22derby%22">Apache Derby</a></li>
        <li><a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.h2database%22%20AND%20a%3A%22h2%22">H2</a></li>
        <li><a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22hsqldb%22%20AND%20a%3A%22hsqldb%22">HSQLDB</a></li>
        <li><a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22net.sourceforge.jtds%22%20AND%20a%3A%22jtds%22">MS SQL Server jTDS</a></li>
        <li><a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22mysql%22%20AND%20a%3A%22mysql-connector-java%22">MySQL</a></li>
        <li><a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.postgresql%22%20AND%20a%3A%22postgresql%22">Postgresql</a></li>
        <li><a href="http://search.maven.org/#search%7Cgav%7C1%7Cg%3A%22org.xerial%22%20AND%20a%3A%22sqlite-jdbc%22">SQLite</a></li>
      </ul>

      <p>For example, the Postgresql driver:</p>

{% highlight clj %}
[org.postgresql/postgresql "42.2.2"]
{% endhighlight %}

      <p><em>HugSQL defaults to using
          the <code>clojure.java.jdbc</code> library to run underlying
          database commands.  If you would prefer to use another
          underlying database library instead
          of <code>clojure.java.jdbc</code>, such
          as <code>clojure.jdbc</code>, please see <a href="#adapter">HugSQL Adapters</a></em></p>

      <h3 class="page-header" id="start">Getting Started</h3>

      <p>This documentation make use
          of <a href="https://github.com/layerware/hugsql/tree/master/examples/princess-bride"><em>The
          Princess Bride</em> example application</a> in the HugSQL
          repository.  Feel free to view or clone the repo and run the
        application with <code>lein as-you-wish</code>.</p>

        <p><img src="/img/princess_bride_hug.jpg" height="200" title="The Princess Bride"></p>

      <h4 id="start-sql">Start with SQL</h4>

      <p>HugSQL provides a clean separation of SQL and Clojure code.
        You can start developing with HugSQL by deciding where to put
        your SQL files in your application.</p>

      <p>HugSQL can find any SQL file in your classpath.  You can
        place your SQL files under <code>resources</code>,
        <code>src</code>, or elsewhere in your classpath.</p>

      <p>Our example application puts SQL files under <code>src</code>:</p>

<pre>
  .../examples/princess-bride $ tree
  .
  ├── LICENSE
  ├── project.clj
  ├── README.md
  ├── resources
  ├── src
  │   └── princess_bride
  │       ├── core.clj
  │       ├── db
  │       │   ├── characters.clj
  │       │   ├── quotes.clj
  │       │   └── sql
  │       │       ├── characters.sql
  │       │       └── quotes.sql
  │       └── db.clj
</pre>

<p>Our SQL for <em>The Princess Bride</em> characters is as follows:</p>

{% highlight sql %}

-- src/princess_bride/db/sql/characters.sql
-- The Princess Bride Characters

-- :name create-characters-table
-- :command :execute
-- :result :raw
-- :doc Create characters table
--  auto_increment and current_timestamp are
--  H2 Database specific (adjust to your DB)
create table characters (
  id         integer auto_increment primary key,
  name       varchar(40),
  specialty  varchar(40),
  created_at timestamp not null default current_timestamp
)

/* ...snip... */

-- A :result value of :n below will return affected rows:
-- :name insert-character :! :n
-- :doc Insert a single character returning affected row count
insert into characters (name, specialty)
values (:name, :specialty)

-- :name insert-characters :! :n
-- :doc Insert multiple characters with :tuple* parameter type
insert into characters (name, specialty)
values :tuple*:characters

/* ...snip... */

-- A ":result" value of ":1" specifies a single record
-- (as a hashmap) will be returned
-- :name character-by-id :? :1
-- :doc Get character by id
select * from characters
where id = :id

-- Let's specify some columns with the
-- identifier list parameter type :i* and
-- use a value list parameter type :v* for IN()
-- :name characters-by-ids-specify-cols :? :*
-- :doc Characters with returned columns specified
select :i*:cols from characters
where id in (:v*:ids)

{% endhighlight %}

      <p>HugSQL uses special SQL comments to accomplish its work.
      These conventions are explained later in this document. Keep
      reading!</p>

      <h4 id="start-clj">Now Some Clojure</h4>

      <p>Now we write a bit of Clojure to define our database functions.</p>

{% highlight clj %}

(ns princess-bride.db.characters
  (:require [hugsql.core :as hugsql]))

;; The path is relative to the classpath (not proj dir!),
;; so "src" is not included in the path.
;; The same would apply if the sql was under "resources/..."
;; Also, notice the under_scored path compliant with
;; Clojure file paths for hyphenated namespaces
(hugsql/def-db-fns "princess_bride/db/sql/characters.sql")


;; For most HugSQL usage, you will not need the sqlvec functions.
;; However, sqlvec versions are useful during development and
;; for advanced usage with database functions.
(hugsql/def-sqlvec-fns "princess_bride/db/sql/characters.sql")

{% endhighlight %}

      <p>The <code>princess-bride.db.characters</code> namespace now
      has several functions defined based on the SQL statements in the
      SQL file.  Here's an example of the sqlvec output and a sample
      run of the <code>characters-by-ids-specify-cols</code> function:</p>

{% highlight clj %}

(characters/characters-by-ids-specify-cols-sqlvec
  {:ids [1 2], :cols ["name" "specialty"]})  ;;=>
["select name, specialty from characters
  where id in (?,?)"
,1
,2]

(characters/characters-by-ids-specify-cols db
  {:ids [1 2], :cols ["name" "specialty"]})  ;;=>
({:name "Westley", :specialty "love"}
 {:name "Buttercup", :specialty "beauty"})

{% endhighlight %}

      <p>You've only scratched the surface of HugSQL's functionality.  Keep
        reading for full usage examples.</p>



      <h3 class="page-header" id="using-hugsql">Using HugSQL</h3>

      <p>This section provides practical usage examples with HugSQL.
        Most examples come
        from <a href="https://github.com/layerware/hugsql/tree/master/examples/princess-bride"><em>The
        Princess Bride</em> example application</a> in the HugSQL
        repository.</p>

      <h4 id="using-def-db-fns">def-db-fns</h4>

      <p><code>hugsql.core/def-db-fns</code> is a macro that creates
      functions in your Clojure namespace based on the SQL queries and
        statements in your HugSQL-flavored SQL file.</p>

      <p><code>hugsql.core/def-db-fns</code> doc:</p>

{% highlight text %}
=> (doc hugsql.core/def-db-fns)
-------------------------
hugsql.core/def-db-fns
([file] [file options])
Macro
  Given a HugSQL SQL file, define the database
   functions in the current namespace.

   Usage:

   (def-db-fns file options?)

   where:
    - file is a string file path in your classpath,
      a resource object (java.net.URL),
      or a file object (java.io.File)
    - options (optional) hashmap:
      {:quoting :off(default) | :ansi | :mysql | :mssql
       :adapter adapter }

   :quoting options for identifiers are:
     :ansi double-quotes: "identifier"
     :mysql backticks: `identifier`
     :mssql square brackets: [identifier]
     :off no quoting (default)

   Identifiers containing a period/dot . are split, quoted separately,
   and then rejoined. This supports myschema.mytable conventions.

   :quoting can be overridden as an option in the calls to functions
   created by def-db-fns.

   :adapter specifies the HugSQL adapter to use for all defined
   functions. The default adapter used is
   (hugsql.adapter.clojure-java-jdbc/hugsql-adapter-clojure-java-jdbc)
   when :adapter is not given.

   See also hugsql.core/set-adapter! to set adapter for all def-db-fns
   calls.  Also, :adapter can be specified for individual function
   calls (overriding set-adapter! and the :adapter option here).
{% endhighlight %}

      <p>The functions defined by <code>def-db-fns</code> have the following arities:</p>

{% highlight clj %}
      [db]
      [db param-data]
      [db param-data options & command-options]
{% endhighlight %}

      <p>where:</p>

      <ul>
        <li><code>db</code> is a db-spec, a connection, a connection
        pool, or a transaction object</li>
        <li><code>param-data</code> is a hashmap of parameter data
        where the keys match parameter placeholder names in your
          SQL</li>
        <li><code>options</code> is a hashmap of HugSQL-specific
          options (e.g., <code>:quoting</code> and <code>:adapter</code>)</li>
        <li><code>& command-options</code> is a variable number of
        options to be passed down into the underlying adapter and
          database library functions.  See <a href="#using-advanced">Advanced Usage</a> for more detail.</li>
        </ul>

      <h4 id="using-def-sqlvec-fns">def-sqlvec-fns</h4>

      <p>HugSQL generates a format internally known
        as <b>sqlvec</b>. The <b>sqlvec</b> format is a vector with an
        SQL string in the first position containing any <code>?</code>
        placeholders, followed by any number of parameter values to be
        applied to the SQL in positional order.  For example:

{% highlight clj %}
["select * from characters where id = ?", 2]
{% endhighlight %}

      <p>The <b>sqlvec</b> format is a convention used
        by <code>clojure.java.jdbc</code> and
        <code>clojure.jdbc</code> for value parameter replacement.
        Because of the underlying support in these libraries and the
        JDBC-driver-specific issues for data type handling, HugSQL
        also uses the <b>sqlvec</b> format by default for value
        parameters.</p>

      <p>HugSQL provides the <code>hugsql.core/def-sqlvec-fns</code>
        macro to create functions returning the <b>sqlvec</b> format.
        The created functions have an <code>-sqlvec</code> suffix by
        default, though this is configurable with
        the <code>:fn-suffix</code> option.  These functions are
        helpful during development/debugging and for the purpose of
        using the parameter-replacing functionality of HugSQL without
        using the built-in adapter database functions to execute
        queries.</p>

      <p><code>hugsql.core/def-sqlvec-fns</code> doc:</p>

{% highlight text %}
=> (doc hugsql.core/def-sqlvec-fns)
-------------------------
hugsql.core/def-sqlvec-fns
([file] [file options])
Macro
  Given a HugSQL SQL file, define the <name>-sqlvec functions in the
  current namespace.  Returns sqlvec format: a vector of SQL and
  parameter values. (e.g., ["select * from test where id = ?" 42])

  Usage:

   (def-sqlvec-fns file options?)

   where:
    - file is a string file path in your classpath,
      a resource object (java.net.URL),
      or a file object (java.io.File)
    - options (optional) hashmap:
      {:quoting :off(default) | :ansi | :mysql | :mssql
       :fn-suffix "-sqlvec" (default)

   :quoting options for identifiers are:
     :ansi double-quotes: "identifier"
     :mysql backticks: `identifier`
     :mssql square brackets: [identifier]
     :off no quoting (default)

   Identifiers containing a period/dot . are split, quoted separately,
   and then rejoined. This supports myschema.mytable conventions.

   :quoting can be overridden as an option in the calls to functions
   created by def-db-fns.

   :fn-suffix is appended to the defined function names to
   differentiate them from the functions defined by def-db-fns.
{% endhighlight %}


      <h4 id="using-other-fns">Other Useful Functions</h4>

      <p>HugSQL has several other useful functions that take HugSQL-flavored
      SQL and can be used in other contexts (like the REPL).  See the
        <a href="http://layerware.github.io/hugsql/">API docs ➚</a> for more information on the following:</p>

      <ul>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-def-db-fns-from-string">
            <code>def-db-fns-from-string</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-def-sqlvec-fns-from-string">
            <code>def-sqlvec-fns-from-string</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-map-of-db-fns">
            <code>map-of-db-fns</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-map-of-sqlvec-fns">
            <code>map-of-sqlvec-fns</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-map-of-db-fns-from-string">
            <code>map-of-db-fns-from-string</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-map-of-sqlvec-fns-from-string">
            <code>map-of-sqlvec-fns-from-string</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-sqlvec">
            <code>sqlvec</code> and alias <code>snip</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-sqlvec-fn">
            <code>sqlvec-fn</code> and alias <code>snip-fn</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-db-run">
            <code>db-run</code> ➚</a></li>
        <li><a href="http://layerware.github.io/hugsql/hugsql.core.html#var-db-fn">
            <code>db-fn</code> ➚</a></li>
      </ul>


      <h4 id="using-ddl">Create,Drop,... (DDL)</h4>

      <p>SQL</p>

{% highlight sql %}
-- :name create-characters-table
-- :command :execute
-- :result :raw
-- :doc Create characters table
--  auto_increment and current_timestamp are
--  H2 Database specific (adjust to your DB)
create table characters (
  id         integer auto_increment primary key,
  name       varchar(40),
  specialty  varchar(40),
  created_at timestamp not null default current_timestamp
)

/* The create-character-table definition above uses the full,
long-hand "-- :key :value" syntax to specify the :command and
:result.  We can save some typing by using the short-hand notation
as the second and (optionally) third values for the :name.  Below, the
:! is equivalent to ":command :!", where :! is an alias for
:execute.  The default :result is :raw when not specified, so
there is no need to specify it as the third value. */

-- :name drop-characters-table :!
-- :doc Drop characters table if exists
drop table if exists characters
{% endhighlight %}

      <p>Clojure:</p>

{% highlight clj %}
(characters/create-characters-table-sqlvec)  ;;=>
["create table characters (
    id         integer auto_increment primary key,
    name       varchar(40),
    specialty  varchar(40),
    created_at timestamp not null default current_timestamp
  )"]

(characters/create-characters-table db)  ;;=>
[0]

(characters/drop-characters-table-sqlvec)  ;;=>
["drop table if exists characters"]

(characters/drop-characters-table db)  ;;=>
[0]

{% endhighlight %}


      <h4 id="using-insert">Insert</h4>

      <p>SQL</p>

{% highlight sql %}
-- A :result value of :n below will return affected row count:
-- :name insert-character :! :n
-- :doc Insert a single character
insert into characters (name, specialty)
values (:name, :specialty)

-- :name insert-characters :! :n
-- :doc Insert multiple characters with :tuple* parameter type
insert into characters (name, specialty)
values :tuple*:characters
{% endhighlight %}

      <p>Clojure:</p>

{% highlight clj %}
(characters/insert-character-sqlvec
 {:name "Westley", :specialty "love"})  ;;=>
["insert into characters (name, specialty)
  values (?, ?)"
,"Westley"
,"love"]

(characters/insert-character db
  {:name "Westley", :specialty "love"})  ;;=>
1

(characters/insert-character db
  {:name "Buttercup", :specialty "beauty"})  ;;=>
1

(characters/insert-characters-sqlvec
 {:characters
  [["Vizzini" "intelligence"]
   ["Fezzik" "strength"]
   ["Inigo Montoya" "swordmanship"]]})  ;;=>
["insert into characters (name, specialty)
  values (?,?),(?,?),(?,?)"
,"Vizzini"
,"intelligence"
,"Fezzik"
,"strength"
,"Inigo Montoya"
,"swordmanship"]

(characters/insert-characters
 db
 {:characters
  [["Vizzini" "intelligence"]
   ["Fezzik" "strength"]
   ["Inigo Montoya" "swordmanship"]]})  ;;=>
3
{% endhighlight %}


        <h5>Retrieving Last Inserted ID or Record</h5>

        <p>It is often the case that you want to return the record
        just inserted or at least the auto-generated ID.  This
        functionality varies greatly across databases and JDBC
        drivers. HugSQL attempts to help where it can. You will
        need to choose an option that fits your database.</p>

        <h6>OPTION #1: INSERT ... RETURNING</h6>
        <p>If your database supports the RETURNING clause of INSERT
          (e.g., <a href="http://www.postgresql.org/docs/current/static/sql-insert.html">Postgresql
          supports this</a>), you can specify your SQL insert statement
          command type to be <code>:returning-execute</code>, or <code>:&lt;!</code> for short:</p>

{% highlight sql %}
-- :name insert-into-test-table-returning :<!
-- :doc insert with an sql returning clause
insert into test (id, name) values (:id, :name) returning id
{% endhighlight %}

        <h6>OPTION #2: Get Generated Keys / Last Insert ID / Inserted Record</h6>
        <p>HugSQL's <code>:insert</code>, or <code>:i!</code> command
        type indicates to the underlying adapter that the insert
        should be performed, and then <code>.getGeneratedKeys</code>
        called in the jdbc driver. The return value
        of <code>.getGeneratedKeys</code> varies greatly across
        different databases and jdbc drivers.  For example, see the
        following code from the HugSQL test suite:
        </p>

        <p>SQL</p>

{% highlight sql %}
-- :name insert-into-test-table-return-keys :insert :raw
insert into test (id, name) values (:id, :name)
{% endhighlight %}

        <p>Clojure:</p>

{% highlight clj %}
(testing "insert w/ return of .getGeneratedKeys"
;; return generated keys, which has varying support and return values
;; clojure.java.jdbc returns a hashmap, clojure.jdbc returns a vector of hashmaps
  (when (= adapter-name :clojure.java.jdbc)
    (condp = db-name
      :postgresql
      (is (= {:id 8 :name "H"}
          (insert-into-test-table-return-keys db {:id 8 :name "H"} {})))

      :mysql
      (is (= {:generated_key 9}
             (insert-into-test-table-return-keys db {:id 9 :name "I"})))

      :sqlite
      (is (= {(keyword "last_insert_rowid()") 10}
             (insert-into-test-table-return-keys db {:id 10 :name "J"} {})))

      :h2
      (is (= {(keyword "scope_identity()") 11}
             (insert-into-test-table-return-keys db {:id 11 :name "J"} {})))

      ;; hsql and derby don't seem to support .getGeneratedKeys
      nil))

  (when (= adapter-name :clojure.jdbc)
    (condp = db-name
      :postgresql
      (is (= [{:id 8 :name "H"}]
             (insert-into-test-table-return-keys db {:id 8 :name "H"} {})))

      :mysql
      (is (= [{:generated_key 9}]
             (insert-into-test-table-return-keys db {:id 9 :name "I"})))

      :sqlite
      (is (= [{(keyword "last_insert_rowid()") 10}]
             (insert-into-test-table-return-keys db {:id 10 :name "J"} {})))

      :h2
      (is (= [{(keyword "scope_identity()") 11}]
             (insert-into-test-table-return-keys db {:id 11 :name "J"} {})))

      ;; hsql and derby don't seem to support .getGeneratedKeys
      nil)))
{% endhighlight %}


      <h4 id="using-update">Update</h4>

<p>SQL</p>

{% highlight sql %}
-- :name update-character-specialty :! :n
update characters
set specialty = :specialty
where id = :id
{% endhighlight %}

      <p>Clojure:</p>

{% highlight clj %}

(let [vizzini (characters/character-by-name db {:name "vizzini"})]
 (characters/update-character-specialty-sqlvec
  {:id (:id vizzini), :specialty "boasting"}))  ;;=>
["update characters
  set specialty = ?
  where id = ?"
,"boasting"
,3]

(let [vizzini (characters/character-by-name db {:name "vizzini"})]
 (characters/update-character-specialty db
  {:id (:id vizzini), :specialty "boasting"}))  ;;=>
1

{% endhighlight %}

      <h4 id="using-delete">Delete</h4>

<p>SQL</p>

{% highlight sql %}
-- :name delete-character-by-id :! :n
delete from characters where id = :id
{% endhighlight %}

      <p>Clojure:</p>

{% highlight clj %}
(let [vizzini (characters/character-by-name db {:name "vizzini"})]
  (characters/delete-character-by-id-sqlvec {:id (:id vizzini)}))  ;;=>
["delete from characters where id = ?",3]

(let [vizzini (characters/character-by-name db {:name "vizzini"})]
  (characters/delete-character-by-id db {:id (:id vizzini)}))  ;;=>
1
{% endhighlight %}

      <h4 id="using-select">Select</h4>

<p>SQL</p>

{% highlight sql %}
-- A ":result" value of ":*" specifies a vector of records
-- (as hashmaps) will be returned
-- :name all-characters :? :*
-- :doc Get all characters
select * from characters
order by id

-- A ":result" value of ":1" specifies a single record
-- (as a hashmap) will be returned
-- :name character-by-id :? :1
-- :doc Get character by id
select * from characters
where id = :id

-- :name character-by-name :? :1
-- :doc Get character by case-insensitive name
select * from characters
where upper(name) = upper(:name)

-- :name characters-by-name-like :?
-- :doc Get characters by name like, :name-like should include % wildcards
select * from characters
where name like :name-like

-- Let's specify some columns with the
-- identifier list parameter type :i* and
-- use a value list parameter type :v* for SQL IN()
-- :name characters-by-ids-specify-cols :? :*
-- :doc Characters with returned columns specified
select :i*:cols from characters
where id in (:v*:ids)


{% endhighlight %}

      <p>Clojure:</p>

{% highlight clj %}
(characters/all-characters-sqlvec)  ;;=>
["select * from characters
  order by id"]

(characters/all-characters db)  ;;=>
({:id 1,
  :name "Westley",
  :specialty "love",
  :created_at #inst "2015-11-09T19:33:58.472000000-00:00"}
 {:id 2,
  :name "Buttercup",
  :specialty "beauty",
  :created_at #inst "2015-11-09T19:33:58.492000000-00:00"}
 {:id 3,
  :name "Vizzini",
  :specialty "boasting",
  :created_at #inst "2015-11-09T19:33:58.530000000-00:00"}
 {:id 4,
  :name "Fezzik",
  :specialty "strength",
  :created_at #inst "2015-11-09T19:33:58.530000000-00:00"}
 {:id 5,
  :name "Inigo Montoya",
  :specialty "swordmanship",
  :created_at #inst "2015-11-09T19:33:58.530000000-00:00"})

(characters/character-by-id-sqlvec {:id 1})  ;;=>
["select * from characters
  where id = ?"
,1]

(characters/character-by-id db {:id 1})  ;;=>
{:id 1,
 :name "Westley",
 :specialty "love",
 :created_at #inst "2015-11-09T19:33:58.472000000-00:00"}

(characters/character-by-name-sqlvec {:name "buttercup"})  ;;=>
["select * from characters
  where upper(name) = upper(?)"
,"buttercup"]

(characters/character-by-name db {:name "buttercup"})  ;;=>
{:id 2,
 :name "Buttercup",
 :specialty "beauty",
 :created_at #inst "2015-11-09T19:33:58.492000000-00:00"}

(characters/characters-by-name-like-sqlvec {:name-like "%zz%"})  ;;=>
["select * from characters
  where name like ?"
,"%zz%"]

(characters/characters-by-name-like db {:name-like "%zz%"})  ;;=>
({:id 3,
  :name "Vizzini",
  :specialty "boasting",
  :created_at #inst "2015-11-09T19:33:58.530000000-00:00"}
 {:id 4,
  :name "Fezzik",
  :specialty "strength",
  :created_at #inst "2015-11-09T19:33:58.530000000-00:00"})

(characters/characters-by-ids-specify-cols-sqlvec
 {:ids [1 2], :cols ["name" "specialty"]})  ;;=>
["select name, specialty from characters
  where id in (?,?)"
,1
,2]

(characters/characters-by-ids-specify-cols
 db
 {:ids [1 2], :cols ["name" "specialty"]})  ;;=>
({:name "Westley", :specialty "love"}
 {:name "Buttercup", :specialty "beauty"})
{% endhighlight %}

      <h4 id="using-transactions">Transactions</h4>

      <p>The first argument of a function generated
      by <code>def-db-fns</code> can take a database spec, a
      connection, a connection pool, or a transaction object. Use your
      underlying database library to get a transaction object.  Here's
      an example
      with <code>clojure.java.jdbc/with-db-transaction</code>:</p>

{% highlight clj %}
(clojure.java.jdbc/with-db-transaction [tx db]
  (characters/insert-character tx
   {:name "Miracle Max", :specialty "miracles"})
  (characters/insert-character tx
   {:name "Valerie", :specialty "speech interpreter"}))
{% endhighlight %}

      <h4 id="using-expressions">Clojure Expressions</h4>

      <p>Clojure Expressions give HugSQL SQL statements the full power
      of Clojure to conditionally compose portions of SQL during
      runtime.</p>

      <p>Expressions are written within SQL comments (in keeping
      with the SQL-first workflow).</p>

      <p>Expressions should return a string or nil. The string
        returned may contain HugSQL-specific parameter syntax.</p>

      <p>Expressions have two bound symbols available at
      runtime: <code>params</code>, which is the hashmap of parameter
      data, and <code>options</code>, which is the hashmap of
      options.</p>

      <p>A <b>single-line comment expression</b> starts
      with <code>--~</code>.  Notice the tilde <code>~</code>. An
      entire Clojure expression is expected to be in a single-line
      comment.</p>

{% highlight sql %}
-- :name clj-expr-single :? :1
select
--~ (if (seq (:cols params)) ":i*:cols" "*")
from test
order by id
{% endhighlight %}

      <p>A <b>multi-line comment expression</b> can have interspersed
      SQL. The expression starts with <code>/*~</code>, all
      "continuing" parts also start with <code>/*~</code>, and the
      expression ends with <code>~*/</code>.  When an expression needs
      to represent advancing to the "next" Clojure form (like
        the <code>if</code> below), an empty separator <code>/*~*/</code> is necessary:</p>

{% highlight sql %}
-- :name clj-expr-multi :? :1
select
/*~ (if (seq (:cols params)) */
:i*:cols
/*~*/
*
/*~ ) ~*/
from test
order by id
{% endhighlight %}

        <p>Expressions are defined and compiled just after the initial file/string parse.</p>

        <p>Expressions needing to access Clojure namespaces other than
        the included clojure.core can specify a <code>:require</code>
        similar to usage in <code>(ns ...):</code></p>

{% highlight sql %}
-- :name clj-expr-generic-update :! :n
/* :require [clojure.string :as string]
            [hugsql.parameters :refer [identifier-param-quote]] */
update :i:table set
/*~
(string/join ","
  (for [[field _] (:updates params)]
    (str (identifier-param-quote (name field) options)
      " = :v:updates." (name field))))
~*/
where id = :id
{% endhighlight %}


{% highlight clj %}
  (clj-expr-generic-update db {:table "test"
                               :updates {:name "X"}
                               :id 3})
{% endhighlight %}


      <h4 id="using-snippets">Snippets</h4>

      <p>Snippets allow query composition by defining and generating
      portions of SQL statements and then using the Snippet Parameter
      Types to place these snippets into a full SQL statement.</p>

      <p>You can define a snippet in your SQL file with
        <code>-- :snip my-snippet</code> (as opposed to <code>:name</code>):</p>

{% highlight sql %}
-- :snip select-snip
select :i*:cols

-- :snip from-snip
from :i*:tables
{% endhighlight %}

      <p>Snippets can contain snippet
      parameters.  Below, <code>:snip*:cond</code> is a Snippet List
      Parameter Type, which specifies that <code>:cond</code> is a
      list/vector of snippets</p>

{% highlight sql %}
-- :snip where-snip
where :snip*:cond
{% endhighlight %}

      <p>Snippets can get very elaborate (creating an entire DSL) if
      you want.  The <code>cond-snip</code> snippet below uses
      <a href="#deep-get-param-name">deep-get parameter name
      access</a> to construct a where clause condition: </p>

{% highlight sql %}
-- :snip cond-snip
-- We could come up with something
-- quite elaborate here with some custom
-- parameter types that convert := to =, etc.,
-- Examples:
-- {:conj "and" :cond ["id" "=" 1]}
-- OR
-- {:conj "or" :cond ["id" "=" 1]}
-- note that :conj can be "", too
:sql:conj :i:cond.0 :sql:cond.1 :v:cond.2
{% endhighlight %}

      <p>Using the above snippets, we can now construct the full
        query. (With an optional where clause via a Clojure expression)</p>


{% highlight sql %}
-- :name snip-query :? :*
:snip:select
:snip:from
--~ (when (:where params) ":snip:where")
{% endhighlight %}

{% highlight clj %}
(snip-query
  db
  {:select (select-snip {:cols ["id","name"]})
   :from (from-snip {:tables ["test"]})
   :where (where-snip {:cond [(cond-snip {:conj "" :cond ["id" "=" 1]})
                              (cond-snip {:conj "or" :cond ["id" "=" 2]})]})})
{% endhighlight %}

      <p><em>It's worth noting that a snippet returns an sqlvec.  This
      small detail gives you a great deal of flexibility in providing
      snippets to your HugSQL queries.  Why? Because you don't
      necessarily need to create your own snippet DSL: you could use
      <a href="https://github.com/jkk/honeysql">another library</a>
      for this.  It is the best of both worlds! This exercise is left
      to the reader.</em></p>

      <h4 id="using-advanced">Advanced Usage</h4>

      <p>Each underlying database library and corresponding HugSQL
        adapter may support additional options for the execute/query
        commands.  Functions defined by <code>def-db-fns</code> have a
        variable-arity 4th argument that passes any options through to
        the underlying database library.</p>

      <p>Below is an assertion from the HugSQL test suite showing a
      query passing along the <code>:as-arrays?</code> option
      to <code>clojure.java.jdbc/query</code>.  Please note the
      required 3rd argument (the HugSQL-specific options) when using
      this passthrough feature:</p>

{% highlight clj %}
(is (= [[:name] ["A"] ["B"]]
      (select-ordered db
        {:cols ["name"] :sort-by ["name"]} {} {:as-arrays? true})))
{% endhighlight %}

      <p><em>Please note that as
      of <code>clojure.java.jdbc</code> <code>0.5.8</code> and HugSQL
      0.4.7, the above additional options are now required to be a
      hashmap instead of keyword arguments as in previous versions. In
      clojure.java.jdbc 0.5.8 the deprecated usage will emit a
      warning.  In clojure.java.jdbc 0.6.0 the usage is deprecated and
      not allowed.  See
      the <a href="https://github.com/clojure/java.jdbc/blob/master/CHANGES.md">clojure.java.jdbc
      changelog</a> for details.</em></p>

      <h3 class="page-header" id="detail">HugSQL in Detail</h3>

      <p>HugSQL encourages SQL, DDL, and DML statements to be stored in SQL
        files such that you are not concatenating large strings or needing to
        use leaky-abstraction DSLs in your Clojure projects.</p>

      <p>In order to generate the Clojure functions from your SQL statements,
        HugSQL requires a simple set of conventions in your SQL files.  These
        conventions allow HugSQL to:</p>

      <ul>
        <li>define functions by name</li>
        <li>add docstrings to defined functions</li>
        <li>determine how to execute (the command type):
          <ul>
            <li>SQL select</li>
            <li>DDL create table/index/view, drop ...</li>
            <li>DML insert, update, delete</li>
            <li>any other statements (e.g. <code>vacuum analyze</code>)</li>
          </ul>
        </li>
        <li>determine the result type:
          <ul>
            <li>one row (hash-map)</li>
            <li>many rows (vector of hash-maps)</li>
            <li>affected rows</li>
            <li>any other result you implement</li>
          </ul>
        </li>
        <li>replace parameters for:
          <ul>
            <li>Values: <code>where id = :id</code></li>
            <li>Value lists: <code>where id in (:v*:ids)</code></li>
            <li>Tuple lists (for multi-insert): <code>values :tuple*:my-records</code></li>
            <li>SQL identifiers: <code>from :i:table-name</code></li>
            <li>SQL identifier lists: <code>select :i*:column-names</code></li>
            <li>SQL keywords: <code>:sql:my-query</code></li>
          </ul>
        </li>
      </ul>

      <h4 id="sql-file">SQL File Conventions</h4>

      <p>HugSQL SQL files contain special single-line comments and multi-line
        comments in the following forms:</p>

{% highlight sql %}

 -- :key value1 value2 value3
 OR
 /* :key
 value1
 value2
 value3
 */

{% endhighlight %}

Examples:

{% highlight sql %}

-- regular SQL comment ignored by hugsql
/*
regular SQL multi-line comment ignored by hugsql
*/

-- :name query-get-many :? :*
-- :doc My query doc string to end of this line
select * from my_table;

-- :name query-get-one :? :1
/* :doc
My multi-line
comment doc string
*/
select * from my_table limit 1

{% endhighlight %}

      <p>HugSQL recognizes the following keys:</p>

      <ul>
        <li><code>:name</code> or <code>:name-</code> (private
          fn) = name of the function to create and, optionally, the
          command and result as a shorthand in place of providing
          these as separate key/value pairs</li>
        <li><code>:doc</code> = docstring for the created function</li>
        <li><code>:command</code> = underlying database command to run</li>
        <li><code>:result</code> = expected result type</li>
        <li><code>:snip</code> or <code>:snip-</code> (private fn)
          = name of the function to create and, optionally, the command
          and result as a shorthand in place of providing these as
          separate key/value pairs.  <code>:snip</code> is used in
          place of <code>:name</code> for snippets.</li>
        <li><code>:meta</code> metadata in the form of an EDN hashmap
          to attach to function</li>
        <li><code>:require</code> = namespace require and aliases for Clojure expression support</li>
      </ul>

      <h4 id="command">Command</h4>

      <p>The <code>:command</code> specifies the underlying database command to run for
        the given SQL.  The built-in values are:</p>

      <ul>
        <li><code>:query</code> or <code>:?</code> = query with a result-set (default)</li>
        <li><code>:execute</code> or <code>:!</code> = any statement</li>
        <li><code>:returning-execute</code> or <code>:&lt;!</code> = support for <code>INSERT ... RETURNING</code></li>
        <li><code>:insert</code> or <code>:i!</code> = support for insert and jdbc <code>.getGeneratedKeys</code></li>
      </ul>

      <p><code>:query</code> and <code>:execute</code> mirror the
      distinction between <code>query</code> and <code>execute!</code>
      in the
          <code>clojure.java.jdbc</code> library and <code>fetch</code> and <code>execute</code> in the
          <code>clojure.jdbc</code> library.</p>

      <p>Read more about <code>:returning-execute</code>
      and <code>:insert</code> in the <a href="#using-insert">Insert
      section</a></p>

      <p><code>:query</code> is the default command when no command is specified.</p>

      <p>To save some typing, the command can be specified as the
          second value for the <code>:name</code> key:</p>

{% highlight sql %}
-- :name all-characters :?
{% endhighlight %}

      <p>You can create command functions of your own by implementing a
        <code>hugsql.core/hugsql-command-fn</code> multimethod.</p>

      <h4 id="result">Result</h4>

      <p>The <code>:result</code> specifies the expected result type for the given SQL.
        The available built-in values are:</p>

      <ul>
        <li><code>:one</code> or <code>:1</code> = one row as a hash-map</li>
        <li><code>:many</code> or <code>:*</code> = many rows as a vector of hash-maps</li>
        <li><code>:affected</code> or <code>:n</code> = number of rows affected (inserted/updated/deleted)</li>
        <li><code>:raw</code> = passthrough an untouched result (default)</li>
      </ul>

      <p><code>:raw</code> is the default when no result is specified.</p>

      <p>To save some typing, the result function can be specified as the third
        value for the <code>:name</code> key.  You must supply a second command value in
        order to use this shorthand convention:</p>

{% highlight sql %}
-- :name all-characters :? :*
{% endhighlight %}


      <p>You can create result functions of your own by implementing a
        <code>hugsql.core/hugsql-result-fn</code> multimethod.</p>




      <h4 id="param-types">Parameter Types</h4>

      <p>Within an SQL statement itself, HugSQL understands several types of
        parameters that can be passed in during the function call. All
        parameter types take the form:</p>

{% highlight clj %}
:param-name
{% endhighlight %}

<p>OR</p>

{% highlight clj %}
:param-type:param-name
{% endhighlight %}

          <p>When a HugSQL-generated function is called, the parameters in an SQL
          statement are replaced at runtime with the hash-map data passed in as
          the function's second argument. The keys of the hash-map are matched
          to the <code>:param-name</code> portion of the parameter. Parameters can be
          repeated throughout an SQL statement, and all instances of a parameter
            will be replaced.</p>

          <h5 id="deep-get-param-name">Aside: Param Name Deep Get</h5>

          <p>The parameter name can optionally use a "deep get" syntax
          to drill down into a parameter data structure.  This syntax
          consists of keywords and integers joined by a
          period <code>.</code>. A keyword is a key for a hashmap.  An
            integer is a vector index. For example:</p>

{% highlight sql %}
-- first-employee :? :1
select * from employees where id = :value:employees.0.id
{% endhighlight %}


{% highlight clj %}
(first-employee db {:employees [{:id 1} {:id 2}]})
;=> {:id 1 :name "Al"}
{% endhighlight %}


          <span id="escaping-colon"></span>
          <h5 id="colon">Aside: The Colon</h5>

          <p>Since HugSQL has commandeered the
          colon <code>:</code> for use, you will need to escape a
          colon with a backslash if you actually need a colon in your
          SQL.  Escaping a colon will prevent HugSQL from interpreting
          the colon as the start of a HugSQL parameter.  For example,
          Postgresql array ranges use colons:</p>

{% highlight sql %}
select my_arr[1\:3] from ...
{% endhighlight %}

          <p>BUT, HugSQL does make one exception to the colon-escaping
          necessity in regard to the Postgresql historical type-casting syntax
          that uses a double-colon <code>::</code> to indicate a
          Postgresql data type. So, HugSQL properly leaves alone a
          double-colon:</p>

{% highlight sql %}
select id::text ...
{% endhighlight %}

{% highlight sql %}
... where id = :id::bigint
{% endhighlight %}

{% highlight sql %}
-- with the param type specified
... where id = :v:id::bigint
{% endhighlight %}

          <h5>Now back to the Parameter Types...</h5>

          <p>HugSQL recognizes the need for different types of parameters in SQL
          statements.  Specifically, SQL treats data values differently from
          identifiers and SQL keywords.  If you are building dynamic queries to
          select specific columns or choose the <code>order by</code> direction, then a
          simple value parameter is not sufficient. HugSQL supports value
          parameters, identifier parameters, and raw sql (keyword) parameters.</p>

          <p>The built-in parameter types are detailed below along with information
          on extending these types and creating new types.</p>

          <h5 id="param-value">SQL Values</h5>


          <p>Value Parameters are replaced at runtime with an
            appropriate SQL data type for the given Clojure data type.</p>

          <p>HugSQL defers the Clojure-to-SQL conversion to the underlying
            database driver using the <a href="#sqlvec">sqlvec</a> format.</p>

          <p>Value Parameters' type is <code>:value</code>, or <code>:v</code> for short.</p>

          <p>Value Parameters are the default parameter type, so you can
            omit the type portion of the parameter placeholder in your SQL
            statements.</p>

          <p>An example:</p>

{% highlight sql %}
--:name value-param :? :*
select * from characters where id = :id

--name value-param-with-param-type :? :*
select * from characters where id = :v:id
{% endhighlight %}

      <p>resulting sqlvec:</p>

{% highlight clj %}
(value-param-sqlvec {:id 42})
;=> ["select * from characters where id = ?" 42]
{% endhighlight %}


      <h5 id="param-value-list">SQL Value Lists</h5>

      <p>Value List Parameters are similar to Value Parameters, but work on
        lists of values needed for <code>in (...)</code> queries.</p>

      <p>Value List Parameters' type is <code>:value*</code>, or <code>:v*</code> for short.</p>

      <p>The <code>*</code> indicates a sequence of zero or more values.</p>

      <p>Each value in the list is treated as a value parameter, and the
        list is joined with a comma.</p>

{% highlight sql %}
--:name value-list-param :? :*
select * from characters where name in (:v*:names)
{% endhighlight %}

 <p>resulting sqlvec:</p>

{% highlight clj %}
(value-list-param-sqlvec {:names ["Fezzik" "Vizzini"]})
;=> ["select * from characters where name in (?,?)" "Fezzik" "Vizzini"]
{% endhighlight %}


      <h5 id="param-tuple">SQL Tuples</h5>

      <p>Tuple Parameters are similar to Value List Parameters in
        that they both work with lists of values.</p>  Tuple
        Parameters differ in that they enclose their values in
        parentheses.  Additionally, while a Tuple Parameter can be
        used like a Value List Parameter (e.g., for an <code>in
        ()</code> clause), it is generally understood that a Tuple
        Parameter's data values may have different data types, but
        Value Parameters values are of the same data type.</p>

      <p>Tuple Parameters' type is <code>:tuple</code>.

      <p>Each value in the list is treated as a Value Parameter. The
      list is joined with a comma and enclosed in parentheses.</p>

{% highlight sql %}
-- :name tuple-param
-- :doc Tuple Param
select * from test
where (id, name) = :tuple:id-name
{% endhighlight %}

 <p>resulting sqlvec:</p>

{% highlight clj %}
(tuple-param-sqlvec {:id-name [1 "A"]})
;=> ["select * from test\nwhere (id, name) = (?,?)" 1 "A"]
{% endhighlight %}

      <p><em>The use of a tuple in the above manner is not supported
      by all databases.  Postgresql, MySQL, and H2 support it.  Derby,
      HSQLDB, and SQLite do not support it.</em></p>


      <h5 id="param-tuple-list">SQL Tuple Lists</h5>

      <p>Tuple List Parameters support lists of tuples.  This is specifically useful for multi-record insert.</p>

      <p>Tuple List Parameters' type is <code>:tuple*</code>.

      <p>Each tuple in the list is treated as a Tuple Parameter. The list is joined with a comma.</p>

{% highlight sql %}
-- :name tuple-param-list
-- :doc Tuple Param List
insert into test (id, name)
values :t*:people
{% endhighlight %}

 <p>resulting sqlvec:</p>

{% highlight clj %}
(tuple-param-list-sqlvec {:people [[1 "Ed"] [2 "Al"] [3 "Bo"]]})
;=> ["insert into test (id, name)\nvalues (?,?),(?,?),(?,?)" 1 "Ed" 2 "Al" 3 "Bo"]
{% endhighlight %}


      <p><em>The use of a tuple list in the above manner is not
      supported by all databases.  Postgresql, MySQL, H2, Derby, and
          SQLite support it. HSQLDB does not support it.</em></p>

      <p><em><b>BATCH INSERTS:</b> It should be noted that Tuple List
      Parameter support is only support for SQL <code>INSERT...VALUES
      (...),(...),(...)</code>  syntax.  This is appropriate for
      small-ish multi-record inserts.  However, this is different than
      large batch support.  The underlying JDBC driver for your
      database has a limit to the size of the SQL and the number of
      allowed bind parameters.  If you are doing large batch inserts,
      you should <code>map</code> or <code>doseq</code> over your
      HugSQL-generated insert function within
      a <a href="#using-transactions">transaction</a>.</em></p>

      <h5 id="param-identifier">SQL Identifiers</h5>

      <p>Identifier Parameters are replaced at runtime with an
        optionally-quoted SQL identifier.</p>

      <p>Identifier Parameters' type is <code>:identifier</code>, or <code>:i</code> for short.

{% highlight sql %}
--:name identifier-param :? :*
select * from :i:table-name
{% endhighlight %}

<p>resulting sqlvec:</p>

{% highlight clj %}
(identifier-param-sqlvec {:table-name "example"})
;=> ["select * from example"]
{% endhighlight %}

<p>As of HugSQL 0.4.6, Identifier Parameters support SQL aliases:</p>

{% highlight clj %}
(identifier-param-sqlvec {:table-name ["example" "my_example"]})
;=> ["select * from example as my_example"]
{% endhighlight %}

          <p>By default, identifiers are not quoted.  You can specify
          your desired quoting as an option when defining your
            functions or as an option when calling your function.</p>

          <p><em class="text-danger">If you are taking identifiers
          from user input, you should use the <code>:quoting</code>
          option to properly quote and escape identifiers to prevent
          SQL injection!</em></p>

          <p>Valid <code>:quoting</code> options are:</p>

          <ul>
            <li><code>:ansi</code> double-quotes: <code>"identifier"</code></li>
            <li><code>:mysql</code> backticks: <code>`identifier`</code></li>
            <li><code>:mssql</code> square brackets: <code>[identifier]</code></li>
            <li><code>:off</code> no quoting (default)</li>
          </ul>

      <p>Identifiers containing a period/dot <code>.</code> are split, quoted separately,
        and then rejoined.  This supports <code>myschema.mytable</code> conventions.</p>

{% highlight clj %}
(hugsql.core/def-db-fns "path/to/good.sql" {:quoting :ansi})
{% endhighlight %}

{% highlight clj %}
(identifier-param-sqlvec {:table-name "example"})
;=> ["select * from \"example\""]
{% endhighlight %}


{% highlight clj %}
(identifier-param-sqlvec {:table-name "schema1.example"} {:quoting :mssql})
;=> ["select * from [schema1].[example]"]
{% endhighlight %}



        <h5 id="param-identifier-list">SQL Identifier Lists</h5>


        <p>Identifier List Parameters are similar to identifier
          parameters, but work on lists of identifiers.  You might use
          these to replace column lists found
          in <code>select</code>, <code>group by</code>, <code>order
          by</code> clauses.</p>

        <p>Identifier List Parameter's type
          is <code>:identifier*</code>, or <code>:i*</code> for
          short.</p>

        <p>The <code>*</code> indicates a sequence of zero or more
          identifiers.</p>

        <p>Each identifier in the list is treated as an identifier
          parameter, and the list is joined with a comma.</p>

{% highlight sql %}
--:name identifier-list-param :? :*
select :i*:column-names, count(*) as population
from example
group by :i*:column-names
order by :i*:column-names
{% endhighlight %}

{% highlight clj %}
(identifier-list-param-sqlvec {:column-names ["state" "city"]})
;=> ["select state, city, count(*) as population\n
;     from example\n
;     group by state, city\n
;     order by state, city"]
{% endhighlight %}

      <p>As of HugSQL 0.4.6, Identifier List Parameters support SQL aliases:</p>

{% highlight sql %}
--:name identifier-list-param :? :*
select :i*:column-names-aliased, count(*) as population
from example
group by :i*:column-names
order by :i*:column-names
{% endhighlight %}

{% highlight clj %}
(let [columns [["state" "my_state"] ["city" "my_city"]]]
  (identifier-list-param-sqlvec {:column-names-aliased columns
                                 :column-names (mapv first columns)}))
;=> ["select state as my_state, city as my_city, count(*) as population\n
;     from example\n
;     group by state, city\n
;     order by state, city"]
{% endhighlight %}

        <h5 id="param-sql">Raw SQL (Keywords)</h5>


        <p>Raw SQL Parameters allow full, un-quoted,
          parameter replacement with raw SQL, allowing you to
          parameterize SQL keywords (and any other SQL parts). You
          might use this to set <code>asc</code> or <code>desc</code>
          on an <code>order by</code> column clause, or you can use
          this to compose many SQL statements into a single statement.</p>

        <p><em class="text-danger">You should take special care to
          always properly validate any incoming user input before
          using Raw SQL Parameters to prevent an SQL injection
          security issue.</em></p>

         <p>SQL Parameters' type is <code>:sql</code></p>

{% highlight sql %}
--:name sql-keyword-param :? :*
select * from example
order by last_name :sql:last_name_sort
{% endhighlight %}

{% highlight clj %}
(def user-input "asc")
(defn validated-asc-or-desc [x] (if (= x "desc") "desc" "asc"))
(sql-keyword-param-sqlvec {:last_name_sort (validated-asc-or-desc user-input)})
;=> ["select * from example\norder by last_name asc"]
{% endhighlight %}

         <h5 id="param-sqlvec">Snippets</h5>

        <p>Snippet parameters are replaced at runtime with the provided snippet/sqlvec.</p>

        <p>See <a href="#using-snippets">Snippets</a> for usage.</p>

        <h5 id="param-sqlvec-lists">Snippet Lists</h5>

        <p>Snippet List parameters are replaced at runtime with the provided list of snippets/sqlvecs.</p>

        <p>See <a href="#using-snippets">Snippets</a> for usage.</p>

      <h5 id="param-custom">Custom Parameter Types</h5>

      <p>You can create your own parameter types by implementing a
        method for the multimethod <code>hugsql.parameters/hugsql-apply-param.</code>:</p>

{% highlight text %}
=> (doc hugsql.parameters/apply-hugsql-param)
-------------------------
hugsql.parameters/apply-hugsql-param
  Implementations of this multimethod apply a hugsql parameter
   for a specified parameter type.  For example:

   (defmethod apply-hugsql-param :value
     [param data options]
     (value-param param data options)

   - :value keyword is the parameter type to match on.
   - param is the parameter map as parsed from SQL
     (e.g., {:type :value :name "id"} )
   - data is the runtime parameter map data to be applied
     (e.g., {:id 42} )
   - options contain hugsql options (see hugsql.core/def-sqlvec-fns)

   Implementations must return a vector containing any resulting SQL
   in the first position and any values in the remaining positions.
   (e.g., ["?" 42])
{% endhighlight %}

      <h3 class="page-header" id="adapter">HugSQL Adapters</h3>

      <p>One of HugSQL's design goals is to balance the coupling of an
        SQL-template library (itself) with an underlying database
        library of the developer's choosing. We could concede to no
        coupling at all--providing only <code>def-sqlvec-fns</code>.
        However, wrapping a few underlying database library functions in
        a protocol provides a nice easy-path for most use cases.  And,
        where necessary to use the underlying database libraries
        directly, HugSQL attempts to stay out of the way and give you
        the tools to do what you want to do.</p>

      <p>In the spirit of the above thoughts, HugSQL provides an
      adapter protocol to allow your choice of underlying database
      library.</p>



      <h4 id="adapter-other">Using Other Adapters</h4>

      <p>HugSQL will default to using the adapter for the
          <code>clojure.java.jdbc</code> library.  If you would prefer
          to use the adapter for <code>clojure.jdbc</code> or another
          adapter, you will need to configure your dependencies and
          set the adapter.</p>

          <p>Leiningen dependency information:</p>

          <p>The <code>hugsql</code> clojar is a meta clojar that pulls in <code>hugsql-core</code>,
          <code>hugsql-adapter</code>, and the default adapter
          <code>hugsql-adapter-clojure-java-jdbc</code>, which uses
          <a href="https://github.com/clojure/java.jdbc">clojure.java.jdbc</a>
          to run database queries.</p>

          <p>If you wish to use a different adapter, you should bypass the <code>hugsql</code>
          clojar and specify <code>hugsql-core</code> and the adapter clojar you desire:

{% highlight clj %}
[com.layerware/hugsql-core "0.4.9"]
[com.layerware/hugsql-adapter-clojure-jdbc "0.4.9"]
{% endhighlight %}

          <p>Within your Clojure code, you will need to explicitly set the adapter.
          You can do this globally (i.e., at app startup) with
          <code>hugsql.core/set-adapter!</code>, or you can specify
          the <code>:adapter</code> as an option when defining your functions
          with <code>hugsql.core/def-db-fns</code>, or you can pass in
          an <code>:adapter</code> option when calling your defined function.

{% highlight clj %}
(ns my-app
  (:require [hugsql.core :as hugsql]
            [hugsql.adapter.clojure-java-jdbc :as cj-adapter]))

(defn app-init []
  (hugsql/set-adapter! (cj-adapter/hugsql-adapter-clojure-java-jdbc)))
{% endhighlight %}

          <p>OR</p>

{% highlight clj %}
(ns my-db-stuff
  (:require [hugsql.core :as hugsql]
            [hugsql.adapter.clojure-java-jdbc :as cj-adapter]))

(hugsql/def-db-fns "path/to/db.sql"
  {:adapter (cj-adapter/hugsql-adapter-clojure-java-jdbc)})
{% endhighlight %}

<p>OR</p>

{% highlight clj %}
(ns my-db-stuff
(:require [hugsql.core :as hugsql]
          [hugsql.adapter.clojure-java-jdbc :as cj-adapter]))

(def db ;;a db-spec here)

(hugsql/def-db-fns "path/to/db.sql")

(my-query db {:id 1}
  {:adapter (cj-adapter/hugsql-adapter-clojure-java-jdbc)})
{% endhighlight %}

      <h4 id="adapter-creation">Create an Adapter</h4>

      <p>Creating a HugSQL Adapter is as simple as implementing
      the <a href="https://github.com/layerware/hugsql/blob/master/hugsql-adapter/src/hugsql/adapter.clj">hugsql.adapter/HugsqlAdapter
      protocol</a>.  For examples, see the implementations
      for <a href="https://github.com/layerware/hugsql/blob/master/hugsql-adapter-clojure-java-jdbc/src/hugsql/adapter/clojure_java_jdbc.clj">clojure.java.jdbc</a>
      and <a href="https://github.com/layerware/hugsql/blob/master/hugsql-adapter-clojure-jdbc/src/hugsql/adapter/clojure_jdbc.clj">clojure.jdbc</a>.</p>

      <h4 id="adapter-community">Adapters from the Community</h4>

      <p>HugSQL's adapter protocol encourages alternative adapters to
      support your preferred database library. Write your own!</p>

      <ul>
        <li><a href="https://gitlab.com/robin.heggelund/hugsql-postgres-async">HugSQL Adapter for postgres.async</a>
          by Robin Heggelund Hansen</li>
      </ul>

      <p>Did you write an
      adapter?  <a href="https://github.com/layerware/hugsql/issues">Add
      an issue</a> and we'll add your adapter here.</p>


      <h3 class="page-header" id="faq">FAQ</h3>

      <h4 id="faq-yesql">Comparison with Yesql</h4>

      <p><a href="https://github.com/krisajenkins/yesql">Yesql</a> is
      a Clojure library written by Kris Jenkins.  It has a similar
      take on <em>using SQL</em> that HugSQL <em>embraces</em> whole-heartedly.
        Certainly, HugSQL would not exist were it not for Kris' great library.</p>

      <p><b>So why build a another similar library?</b>  A recent
      project with some fairly hairy SQL required me to generate
      dynamically-named tables and views with variable columns, and I
      found myself having to revert back to string concatenation for
      building up my SQL. I realized I needed something similar to
      Yesql, but with support for different types of parameter
      placeholders: namely, SQL Identifiers and SQL Keywords.  This
      was the seed that grew into HugSQL, and the two libraries have
        quite a few differences now.</p>

      <p>Differences between Yesql and HugSQL:</p>

      <ul>
        <li>Yesql is coupled to <code>clojure.java.jdbc</code>.
        HugSQL has protocol-based adapters to allow multiple database
        backend libraries and ships with support
        for <code>clojure.java.jdbc</code>
        and <code>clojure.jdbc</code>. This functionality has enabled
        the <a href="https://gitlab.com/robin.heggelund/hugsql-postgres-async">adapter
        for postgres.async</a>. See <a href="#adapter">Hugsql
        Adapters</a> for more information.</li>
        <li>Yesql only supports SQL Value parameters. HugSQL supports
        SQL Values, SQL Identifiers, SQL Tuples, SQL Keywords (Raw
        SQL), and you can create your own custom parameter
        types. See <a href="#detail">HugSQL in Detail</a> for more
        info.</li>
        <li>Yesql supports positional parameter
        placeholders <code>?</code> and named parameter placeholders
        <code>:id</code>.  HugSQL only supports named parameter
        placeholders and there are no plans to support positional
        placeholders.</li>
        <li>Yesql tends to favor naming conventions of the function
        name (<code>!</code>, and <code>&lt!</code> suffixes) to indicate
        functionality.  HugSQL prefers explicit configuration in the
        SQL file.</li>
        <li>HugSQL features a <code>:result</code> configuration that
        indicates the expected return format (e.g., <code>:many</code>
        = vector of hashmaps, <code>:one</code> = hashmap). Yesql
        supports a similar functionality by passing
        the <code>:result-set-fn</code> option through
        to <code>clojure.java.jdbc/query</code>.</li>
        <li>Yesql (as of 0.5.x) supports setting a default database
        connection at the time of function definition, and optionally
        overriding this connection at function call time.  HugSQL
        expects a database spec, connection, or transaction object as
        the first argument to your function call.  However, as of
        version 0.4.1, HugSQL
          provides <a href="http://layerware.github.io/hugsql/hugsql.core.html#var-map-of-db-fns">
            <code>map-of-db-fns</code></a> allowing other libraries to
        wrap HugSQL-created functions and set a default database
        connection. This is precisely what the Luminus web
        framework's <a href="https://github.com/luminus-framework/conman">conman</a>
        library does.</li>
        <li>As of HugSQL 0.4.0, HugSQL
        supports <a href="#using-expressions">Clojure expressions</a>
        and <a href="#using-snippets">Snippets</a> for composing SQL
        from smaller parts.</li>
      </ul>

      <p><em>--Curtis Summers (Feb 2016)</em></p>
      <p>P.S. I'd like to keep the above comparison accurate as both
      libraries grow.  See something that's not
      right?  <a href="https://github.com/layerware/hugsql/issues">Add
          an issue!</a></p>

      <h4 id="faq-wacky-sql">Does HugSQL support my wacky SQL?</h4>

      <p>Yes, HugSQL's parsing strategy is to extract the parts it
      cares about and leave the rest of your SQL as is.  If you find
      some SQL is not being handled properly by HugSQL, it may be a
      bug. <a href="https://github.com/layerware/hugsql/issues">File
      an issue.</a></p>

      <h4 id="faq-dsls">What about DSLs for SQL?</h4>

      <p>Can I get the same flexible SQL generation like I can
      in <a href="https://github.com/jkk/honeysql">Honey SQL</a>?</p>

      <p><b>Yes</b>, as of the HugSQL 0.4.0
      release, <a href="#using-expressions">Clojure expressions</a>
      and <a href="#using-snippets">Snippets</a> provide all of the
        power and flexibility to compose SQL statements.</p>

      <p>HugSQL encourages you to <em>think in SQL</em> first, then
      sprinkle in the power of Clojure where necessary.  HoneySQL
      starts on the Clojure side first.  Both are valid workflows and
      a matter of developer preference and situation. It's important
      to realize that <b>HugSQL and HoneySQL are not mutually exclusive</b>:
      HugSQL Snippet Parameter Types <code>:snip</code>
      and <code>:snip*</code> can consume the sqlvec format output
      from HoneySQL's <code>format</code> function.  It's the best of
        both worlds!</p>

      <h4 id="faq-sql-injection">Preventing SQL Injection</h4>

      <p>How does HugSQL help protect against SQL injection?</p>

      <p>HugSQL attempts to provide a set of tools that help protect
      against SQL injection where possible without taking away power
      from the developer. Below are a few potential SQL injection
      attack vectors and HugSQL's response to each:</p>

      <p><b>Value Parameters</b><br>
        <a href="#param-value">Value
      Parameters</a>, <a href="#param-value-list">Value List
      Parameters</a>, <a href="#param-tuple">Tuple Parameters</a>, and
      <a href="#param-tuple-list">Tuple List Parameters</a> are all
      variations on SQL value parameters that convert a Clojure data
      type to SQL.  By default, all of these parameter types defer to
      the underlying database library to
      perform <a href="http://martinfowler.com/articles/web-security-basics.html#ParameterBindingToTheRescue">SQL
        parameter binding</a> to prevent SQL injection issues.</p>

      <p><b>Identifier Parameters</b><br>
        <a href="#param-identifier">Identifier Parameters</a>
        and <a href="#param-identifier-list">Identifier List
        Parameters</a> support quoting and escaping of identifiers
        with the <code>:quoting</code> option. By
        default, <code>:quoting</code> is <code>:off</code>, since
        HugSQL makes no assumptions about your given database. This
        may be fine for your use case if you are not taking
        identifiers from user input. <em class="text-danger">If you
        are taking identifiers from user input, you should use
        the <code>:quoting</code> option to prevent SQL injection!
        See <a href="#param-identifier">Identifier Parameters</a> for
          details.</em></p>

      <p><b>Raw SQL (Keyword) Parameters</b><br>
        <em class="text-danger"><a href="#param-sql">Raw SQL (Keyword)
        Parameters</a> are exactly what they seem, and it is your
        responsibility to sanitize any usage of this parameter type
        when using user input.</em></p>

      <p><b>Snippet Parameters</b><br>
        <a href="#using-snippets">Snippets</a> generate sqlvecs and
        Snippet Parameter Types consume sqlvecs. For snippets
        containing any HugSQL parameter types, the same rules as above
        apply. If you are consuming a snippet (or sqlvec) from your
        own code or another library (say, HoneySQL), then other rules
        might apply.</p>

      <p><b>Custom Parameter Types</b><br>
        <a href="#param-custom">Custom Parameter Types</a> allow you
        to create your own parameter types.  It is your responsibility
        to ensure your implementation protects against SQL injection
        by properly escaping your data.</p>

      <p><b>Clojure Expressions</b><br>
        <a href="#using-expressions">Clojure Expressions</a> should
        return either a string or nil, and strings returned from
        expressions are parsed at runtime to support HugSQL
        parameters. The same rules apply for the above parameter
        types.</p>


      <h3 class="page-header" id="license">License</h3>

      <p>Copyright © 2018 <a href="http://www.layerware.com">Layerware, Inc.</a></p>

      <p>Distributed under
      the <a href="http://www.apache.org/licenses/LICENSE-2.0.html">Apache
          License, Version 2.0</a></p>

      <p class="xtra-top"></p>

    </div>

    <div class="col-md-1"></div>


    <div class="col-md-3 xtra-top scrollspy">
      <nav id="doc-nav" class="doc-nav hidden-print hidden-sm hidden-xs"
           data-spy="affix" data-offset-top="20" data-offset-bottom="120">
        <ul class="nav">
          <li><a href="#introduction">Introduction</a></li>
          <li><a href="#install">Installation</a></li>
          <li><a href="#start">Getting Started</a>
            <ul class="nav">
              <li><a href="#start-sql">Start with SQL</a></li>
              <li><a href="#start-clj">Now Some Clojure</a></li>
            </ul>
          </li>
          <li><a href="#using-hugsql">Using HugSQL</a>
            <ul class="nav">
              <li><a href="#using-def-db-fns">def-db-fns</a></li>
              <li><a href="#using-def-sqlvec-fns">def-sqlvec-fns</a></li>
              <li><a href="#using-other-fns">Other Useful Functions</a></li>
              <li><a href="#using-ddl">Create,Drop,...(DDL)</a></li>
              <li><a href="#using-insert">Insert</a></li>
              <li><a href="#using-update">Update</a></li>
              <li><a href="#using-delete">Delete</a></li>
              <li><a href="#using-select">Select</a></li>
              <li><a href="#using-transactions">Transactions</a></li>
              <li><a href="#using-expressions">Clojure Expressions</a></li>
              <li><a href="#using-snippets">Snippets</a></li>
              <li><a href="#using-advanced">Advanced Usage</a></li>
            </ul>
          </li>
          <li><a href="#detail">HugSQL in Detail</a>
            <ul class="nav">
              <li><a href="#sql-file">SQL File Conventions</a></li>
              <li><a href="#command">Command</a></li>
              <li><a href="#result">Result</a></li>
              <li><a href="#param-types">Parameter Types</a>
                <ul class="nav">
                  <li><a href="#deep-get-param-name">Deep Get Param Name</a></li>
                  <li><a href="#colon">The Colon</a></li>
                  <li><a href="#param-value">SQL Values</a></li>
                  <li><a href="#param-value-list">SQL Value Lists</a></li>
                  <li><a href="#param-tuple">SQL Tuples</a></li>
                  <li><a href="#param-tuple-list">SQL Tuple Lists</a></li>
                  <li><a href="#param-identifier">SQL Identifiers</a></li>
                  <li><a href="#param-identifier-list">SQL Identifier Lists</a></li>
                  <li><a href="#param-sql">Raw SQL (Keywords)</a></li>
                  <li><a href="#param-sqlvec">Snippets</a></li>
                  <li><a href="#param-sqlvec-lists">Snippet Lists</a></li>
                  <li><a href="#param-custom">Custom Parameter Types</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#adapter">HugSQL Adapters</a>
            <ul class="nav">
              <li><a href="#adapter-other">Using Other Adapters</a></li>
              <li><a href="#adapter-creation">Create an Adapter</a></li>
              <li><a href="#adapter-community">Adapters from the Community</a></li>
            </ul>
          <li><a href="#faq">FAQ</a>
            <ul class="nav">
              <li><a href="#faq-yesql">Comparison with Yesql</a></li>
              <li><a href="#faq-wacky-sql">Does it support my wacky SQL?</a></li>
              <li><a href="#faq-dsls">What about DSLs for SQL?</a></li>
              <li><a href="#faq-sql-injection">Preventing SQL Injection</a></li>
            </ul>
          </li>
          <li><a href="#license">License</a></li>
        </ul>
      </nav>
    </div>

  </div>

</div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-70045003-1', 'auto');
  ga('send', 'pageview');
</script>
